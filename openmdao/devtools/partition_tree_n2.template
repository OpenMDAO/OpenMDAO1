% s
    <style type="text/css">
        #all_pt_n2_content_div * {
            font-family: helvetica, sans-serif;
        }
        #currentPathId {
            font-family: "Courier New", Courier;
            font-size: 18px;
            margin-left: 10px;
            margin-top: 20px;
        }
        #d3_content_div .chart {
            margin-left: 10px;
            margin-top: 20px;
        }
        #d3_content_div .legend {
            margin-left: 10px;
            margin-top: 60px;
        }
        .control_panel fieldset {
            display: inline-block;
            border: 2px solid #1F497D;
            background: #ddd;
            border-radius: 10px;
            padding: 15px;
        }
        .control_panel legend {
            background: #1F497D;
            color: #fff;
            font-size: 18px;
            border-radius: 5px;
        }
        span.control_panel {
            display: inline-block;
            vertical-align: top;
            margin-top: 5px;
        }
        .control_panel button, .control_panel select, .control_panel label{
            margin-top: 2px;
            border-top: 1px solid #96d1f8;
            background: steelblue;
            border-radius: 80px;
            color: white;
            font-size: 12px;
            padding: 5px 10px 5px 10px;
        }
        .control_panel button:hover, .control_panel select:hover {
            border-top-color: #28597a;
            background: #28597a;
            color: #ccc;
        }
        .control_panel button:active, .control_panel select:active {
            border-top-color: #1b435e;
            background: #1b435e;
        }
        .control_panel input[type="checkbox"] {
          display: none;
        }
        .control_panel label {
          position: relative;
          padding-left: 30px;
          white-space: nowrap;
          cursor: pointer;
          transition: background-color .2s;
        }
        .control_panel label::before {
          content: '';
          position: absolute;
          top: 5px;
          bottom: 5px;
          left: 5px;
          width: 10px;
          border: 1px solid #fff;
          border-radius: 100px;
          transition: background-color .2s;
        }
        .control_panel input[type="checkbox"]:checked + label {
          background-color: #00f;
        }
        .control_panel input[type="checkbox"]:checked + label::before {
          background-color: #0f0;
        }
    </style>
    <div id="all_pt_n2_content_div">
        <div id="instructions">
            <h1>OpenMDAO Partition Tree and N^2 diagram.</h1>
            <p>Left clicking on a node in the partition tree will navigate to that node. Right clicking on a node in the partition tree will collapse/uncollapse it. A click on any element in the N^2 diagram will allow those arrows to persist.</p>
        </div>
        <span class="control_panel">
            <fieldset>
                <legend><b> Collapse Algorithms </b> </legend>
                <button onclick="CollapseOutputsButtonClick(root)">Collapse All Outputs</button>
                <button onclick="CollapseOutputsButtonClick(zoomedElement)">Collapse Outputs In View</button>
                <button onclick="UncollapseButtonClick(root)">Uncollapse All</button>
                <button onclick="UncollapseButtonClick(zoomedElement)">Uncollapse In View</button>
                <select id="myCollapseDepthSelect" onchange="CollapseToDepthSelectChange()">
                    <option value="CollapseDepth">Collapse Depth</option>
                </select>
            </fieldset>
        </span>
        <span class="control_panel">
            <fieldset>
                <legend><b> Navigation </b> </legend>
                <button onclick="ReturnToRootButtonClick()">Return To Root</button>
            </fieldset>
        </span>
        <br />
        <span class="control_panel">
            <fieldset>
                <legend><b> Display </b> </legend>
                <button onclick="ClearArrows()">Clear Arrows</button>
                <select id="fontSizeSelect" onchange="FontSizeSelectChange()">
                    <option value="Font Size" id="fontSizeFirstOption">Font Size</option>
                    <option value="8">8 px</option>
                    <option value="9">9 px</option>
                    <option value="10">10 px</option>
                    <option value="11">11 px</option>
                    <option value="12">12 px</option>
                    <option value="13">13 px</option>
                    <option value="14">14 px</option>
                </select>
                <select id="outputNamingSelect" onchange="OutputNameSelectChange()" style="display:none">
                    <option value="Output Naming" id="outputNamingFirstOption">Output Naming</option>
                    <option value="Absolute">Absolute</option>
                    <option value="Promoted">Promoted</option>
                </select>
                <select id="paramViewSelect" onchange="ParamViewSelectChange()">
                    <option value="Params" id="paramViewFirstOption">Params</option>
                    <option value="Hidden">Hidden</option>
                    <option value="Visible">Visible</option>
                </select>
                <input id="showCurrentPathCheckbox" type="checkbox" onchange="ShowPathCheckboxChange()">
                <label for="showCurrentPathCheckbox">Show Path</label>
            </fieldset>
        </span>
        <span class="control_panel">
            <fieldset>
                <legend><b> Save </b> </legend>
                <button onclick="SaveSvg()">Save Svg</button>
            </fieldset>
        </span>
        <div id="currentPathId"></div>
        <div id="d3_content_div"></div>
    </div>
    <!-- insert d3 library below this line -->
    % s
    <script type="text/javascript">
        /**
        * vkBeautify - javascript plugin to pretty-print or minify text in XML, JSON, CSS and SQL formats.
        *
        * Version - 0.99.00.beta
        * Copyright (c) 2012 Vadim Kiryukhin
        * vkiryukhin @ gmail.com
        * http://www.eslinstructor.net/vkbeautify/
        *
        * MIT license:
        *   http://www.opensource.org/licenses/mit-license.php
        *
        *   Pretty print
        *
        *        vkbeautify.xml(text [,indent_pattern]);
        *
        *
        *        @text - String; text to beatufy;
        *        @indent_pattern - Integer | String;
        *                Integer:  number of white spaces;
        *                String:   character string to visualize indentation ( can also be a set of white spaces )
        */

        (function() {

            function createShiftArr(step) {

                var space = '    ';

                if ( isNaN(parseInt(step)) ) {  // argument is string
                    space = step;
                } else { // argument is integer
                    switch(step) {
                        case 1: space = ' '; break;
                        case 2: space = '  '; break;
                        case 3: space = '   '; break;
                        case 4: space = '    '; break;
                        case 5: space = '     '; break;
                        case 6: space = '      '; break;
                        case 7: space = '       '; break;
                        case 8: space = '        '; break;
                        case 9: space = '         '; break;
                        case 10: space = '          '; break;
                        case 11: space = '           '; break;
                        case 12: space = '            '; break;
                    }
                }

                var shift = ['\n']; // array of shifts
                for(ix=0;ix<100;ix++){
                    shift.push(shift[ix]+space);
                }
                return shift;
            }

            function vkbeautify(){
                this.step = '\t'; // 4 spaces
                this.shift = createShiftArr(this.step);
            };

            vkbeautify.prototype.xml = function(text,step) {

                var ar = text.replace(/>\s{0,}</g,"><")
                             .replace(/</g,"~::~<")
                             .replace(/\s*xmlns\:/g,"~::~xmlns:")
                             .replace(/\s*xmlns\=/g,"~::~xmlns=")
                             .split('~::~'),
                    len = ar.length,
                    inComment = false,
                    deep = 0,
                    str = '',
                    ix = 0,
                    shift = step ? createShiftArr(step) : this.shift;

                    for(ix=0;ix<len;ix++) {
                        // start comment or <![CDATA[...]]> or <!DOCTYPE //
                        if(ar[ix].search(/<!/) > -1) {
                            str += shift[deep]+ar[ix];
                            inComment = true;
                            // end comment  or <![CDATA[...]]> //
                            if(ar[ix].search(/-->/) > -1 || ar[ix].search(/\]>/) > -1 || ar[ix].search(/!DOCTYPE/) > -1 ) {
                                inComment = false;
                            }
                        } else
                        // end comment  or <![CDATA[...]]> //
                        if(ar[ix].search(/-->/) > -1 || ar[ix].search(/\]>/) > -1) {
                            str += ar[ix];
                            inComment = false;
                        } else
                        // <elm></elm> //
                        if( /^<\w/.exec(ar[ix-1]) && /^<\/\w/.exec(ar[ix]) &&
                            /^<[\w:\-\.\,]+/.exec(ar[ix-1]) == /^<\/[\w:\-\.\,]+/.exec(ar[ix])[0].replace('/','')) {
                            str += ar[ix];
                            if(!inComment) deep--;
                        } else
                         // <elm> //
                        if(ar[ix].search(/<\w/) > -1 && ar[ix].search(/<\//) == -1 && ar[ix].search(/\/>/) == -1 ) {
                            str = !inComment ? str += shift[deep++]+ar[ix] : str += ar[ix];
                        } else
                         // <elm>...</elm> //
                        if(ar[ix].search(/<\w/) > -1 && ar[ix].search(/<\//) > -1) {
                            str = !inComment ? str += shift[deep]+ar[ix] : str += ar[ix];
                        } else
                        // </elm> //
                        if(ar[ix].search(/<\//) > -1) {
                            str = !inComment ? str += shift[--deep]+ar[ix] : str += ar[ix];
                        } else
                        // <elm/> //
                        if(ar[ix].search(/\/>/) > -1 ) {
                            str = !inComment ? str += shift[deep]+ar[ix] : str += ar[ix];
                        } else
                        // <? xml ... ?> //
                        if(ar[ix].search(/<\?/) > -1) {
                            str += shift[deep]+ar[ix];
                        } else
                        // xmlns //
                        if( ar[ix].search(/xmlns\:/) > -1  || ar[ix].search(/xmlns\=/) > -1) {
                            str += shift[deep]+ar[ix];
                        }

                        else {
                            str += ar[ix];
                        }
                    }

                return  (str[0] == '\n') ? str.slice(1) : str;
            }


            window.vkbeautify = new vkbeautify();

        })();
    </script>
    <script type="text/javascript">
        var FONT_SIZE_PX = 11;
        var svgStyleElement = document.createElement("style");

        var fontSizeSelectElement = document.getElementById("fontSizeSelect");
        var fontSizeFirstOption = document.getElementById("fontSizeFirstOption");
        fontSizeFirstOption.text = "Font Size (" + FONT_SIZE_PX + " px)";
        fontSizeSelectElement.selectedIndex = 0;

        var outputNamingType = "Absolute";
        var outputNamingSelectElement = document.getElementById("outputNamingSelect");
        var outputNamingFirstOption = document.getElementById("outputNamingFirstOption");
        outputNamingFirstOption.text = "Output Naming (" + outputNamingType + ")";
        outputNamingSelectElement.selectedIndex = 0;

        var paramViewType = "Hidden";
        var paramViewSelectElement = document.getElementById("paramViewSelect");
        var paramViewFirstOption = document.getElementById("paramViewFirstOption");
        paramViewFirstOption.text = "Params (" + paramViewType + ")";
        paramViewSelectElement.selectedIndex = 0;

        var currentPathElement = document.getElementById("currentPathId");
        document.getElementById("showCurrentPathCheckbox").checked = false;
        ShowPathCheckboxChange();

        var showParams = false;

        //color constants
        var n2OffDiagonalColor = "#AAA",
            n2OnDiagonalImplicitColor = "orange",
            n2OnDiagonalExplicitColor = "black",
            n2ArrowRedColor = "salmon",
            n2ArrowGreenColor = "seagreen",
            n2HighlightHoveredColor = "blue",
            n2ComponentBoxColor = "#555",
            n2BackgroundColor = "#eee",
            n2GridlineColor = "white",
            ptStrokeColor = "#eee",
            ptUnknownColor = "#aaa",
            ptUnknownGroupColor = "#888",
            ptParamColor = "GoldenRod",
            ptParamGroupColor = "darkkhaki",
            ptSubsystemColor = "steelblue",
            ptComponentColor = "DeepSkyBlue",
            ptCollapsedColor = "#555";


        function UpdateSvgCss(){
            var myCssText =
            "rect { " +
            "    stroke: " + ptStrokeColor + "; " +
            "} " +
            "g.unknown > rect { " +
            "    fill: " + ptUnknownColor + "; " +
            "    fill-opacity: .8; " +
            "} " +
            "g.param > rect { " +
            "    fill: " + ptParamColor + "; " +
            "    fill-opacity: .8; " +
            "} " +
            "g.subsystem > rect { " +
            "    cursor: pointer; " +
            "    fill-opacity: .8; " +
            "    fill: " + ptSubsystemColor + "; " +
            "} " +
            "g.component > rect { " +
            "    cursor: pointer; " +
            "    fill-opacity: .8; " +
            "    fill: " + ptComponentColor + "; " +
            "} " +
            "g.param_group > rect { " +
            "    cursor: pointer; " +
            "    fill-opacity: .8; " +
            "    fill: " + ptParamGroupColor + "; " +
            "} " +
            "g.unknown_group > rect { " +
            "    cursor: pointer; " +
            "    fill-opacity: .8; " +
            "    fill: " + ptUnknownGroupColor + "; " +
            "} " +
            "g.minimized > rect { " +
            "    cursor: pointer; " +
            "    fill-opacity: .8; " +
            "    fill: " + ptCollapsedColor + "; " +
            "} " +
            "text { " +
            //"    dominant-baseline: middle; " +
            //"    dy: .35em; " +
            "} " +
            "g.partition_group > text { " +
            "    text-anchor: end; " +
            "    pointer-events: none; " +
            "    font-family: helvetica, sans-serif; " +
            "    font-size: " + FONT_SIZE_PX +"px; " +
            "} " +
            "/* n2 diagram*/  " +
            "g.component_box > rect { " +
            "    stroke: " + n2ComponentBoxColor + "; " +
            "    stroke-width: 2; " +
            "    fill: none; " +
            "} " +
            ".bordR1, .bordR2, .bordR3, .bordR4, .ssMid, .grpMid, .svMid, .vsMid, .vMid, .sgrpMid, .grpsMid { " +
            "    stroke: none; " +
            "    stroke-width: 0; " +
            "    fill-opacity: 1; " +
            "} " +
            "[class^=n2_hover_elements] { " +
            "    pointer-events: none; " +
            "} " +
            ".background { " +
            "    fill: " + n2BackgroundColor + "; " +
            "} " +
            ".horiz_line, .vert_line { /*n2 gridlines*/ " +
            "    stroke: " + n2GridlineColor + "; " +
            "}";

            svgStyleElement.innerHTML = myCssText;
        }


        var widthPTreePx = 1,
            kx=0, ky=0, kx0=0, ky0=0,
            HEIGHT_PX = 600,
            PARENT_NODE_WIDTH_PX = 40,
            SVG_MARGIN = 1,
            TRANSITION_DURATION = 1000,
            xScalerPTree = d3.scaleLinear().range([0, widthPTreePx]),
            yScalerPTree = d3.scaleLinear().range([0, HEIGHT_PX]),
            xScalerPTree0 = null,
            yScalerPTree0 = null,
            LEVEL_OF_DETAIL_THRESHOLD = HEIGHT_PX / 3; //3 pixels
        var root;
        var sharedTransition;
        var idCounter = 0;
        var d3NodesArray, d3RightTextNodesArrayZoomed = [], d3RightTextNodesArrayZoomedBoxInfo;
        var maxDepth = 1;
        var RIGHT_TEXT_MARGIN_PX = 8; // How much space in px (left and) right of text in partition tree

        //N^2 vars
        var WIDTH_N2_PX = HEIGHT_PX,
            PTREE_N2_GAP_PX = 10; //spacing between partition tree and n2 diagram
        var n2Dx = 0, n2Dy = 0, n2Dx0 = 0, n2Dy0 = 0;
        var matrix;





        var svgDiv = d3.select("#d3_content_div").append("div")
            .attr("class", "chart");

        var svg = svgDiv.append("svg:svg")
            .attr("id","svgId");


        document.getElementsByTagName("svg")[0].appendChild(svgStyleElement);
        UpdateSvgCss();


        var arrowMarker = svg.append("svg:defs").append("svg:marker");


        arrowMarker
            .attr("id", "arrow")
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 5)
            .attr("refY", 0)
            .attr("markerWidth", 1)
            .attr("markerHeight", 1)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-5L10,0L0,5")
            .attr("class", "arrowHead");



        var n2Group = svg.append("g");

        var pTreeGroup = svg.append("g");

        n2Group.append("rect")
            .attr("class", "background")
            .attr("width", WIDTH_N2_PX)
            .attr("height", HEIGHT_PX);

        var n2ElementsGroup = n2Group.append("g"),
            n2GridLinesGroup = n2Group.append("g"),
            n2ComponentBoxesGroup = n2Group.append("g"),
            n2ArrowsGroup = n2Group.append("g"),
            n2DotsGroup = n2Group.append("g");


        function DrawBorder(g,u,v,color,justUpdate){
            var shape1 = justUpdate ? g.select(".bordR1") : g.append("rect").attr("class", "bordR1").style("fill", color);
            var shape2 = justUpdate ? g.select(".bordR2") : g.append("rect").attr("class", "bordR2").style("fill", color);
            var shape3 = justUpdate ? g.select(".bordR3") : g.append("rect").attr("class", "bordR3").style("fill", color);
            var shape4 = justUpdate ? g.select(".bordR4") : g.append("rect").attr("class", "bordR4").style("fill", color);

            shape1.attr("x", -u).attr("y", -v).attr("width", u * 2).attr("height", v * .2);
            shape2.attr("x", -u).attr("y", -v).attr("width", u * .2).attr("height", v * 2);
            shape3.attr("x", u * .8).attr("y", -v).attr("width", u * .2).attr("height", v * 2);
            shape4.attr("x", -u).attr("y", v * .8).attr("width", u * 2).attr("height", v * .2);
        }
        function DrawScalar(g,u,v,color,justUpdate){
            var shape = justUpdate ? g.select(".sMid") : g.append("ellipse").attr("class", "sMid").style("fill", color);
            return shape.attr("rx", u * .6).attr("ry", v * .6);
        }
        function DrawGroup(g,u,v,color,justUpdate){
            DrawBorder(g,u,v,color,justUpdate);
            var shape = justUpdate ? g.select(".gMid") : g.append("rect").attr("class", "gMid").style("fill", color);
            return shape.attr("x", -u*.6).attr("y", -v*.6).attr("width", u*1.2).attr("height", v*1.2);
        }
        function DrawVector(g,u,v,color,justUpdate){
            var shape = justUpdate ? g.select(".vMid") : g.append("rect").attr("class", "vMid").style("fill", color);
            return shape.attr("x", -u*.6).attr("y", -v*.6).attr("width", u*1.2).attr("height", v*1.2);
        }
        function DrawLegendColor(g,u,v,color,justUpdate){
            var shape = justUpdate ? g.select(".colorMid") : g.append("rect").attr("class", "colorMid").style("fill", color);
            return shape.attr("x", -u).attr("y", -v).attr("width", u*2).attr("height", v*2)
                .style("stroke-width", 0).style("fill-opacity", 1);
        }



        var zoomedElement = root = % s;


        var conns = % s;


        var zoomedElement0 = root;
        var lastRightClickedElement = root,
            lastRightClickedElementIndex = 0;

        var enterIndex = 0,
            exitIndex = 0;

        var lastLeftClickedElement = root,
            leftClickIsForward = true,
            lastClickWasLeft = true;

        ExpandColonVars(root);
        FlattenColonGroups(root);
        InitTree(root, null, 1);
        ComputeLayout();
        ComputeConnections();
        ComputeMatrixN2();


        var collapseDepthSelectElement = document.getElementById("myCollapseDepthSelect");
        for(var i=2; i<=maxDepth; ++i){
            var option = document.createElement("option");
            option.text = "" + i + "";
            option.value = "" + i + "";
            option.id = "myCollapseDepthSelectOption" + i;
            collapseDepthSelectElement.add(option);
        }

        update();
        SetupLegend();


        function update() {
            currentPathElement.innerHTML = "PATH: root" + ((zoomedElement.parent) ? "." : "") + zoomedElement.absPathName;
            sharedTransition = d3.transition().duration(TRANSITION_DURATION);

            //update svg dimensions before ComputeLayout() changes widthPTreePx
            svgDiv.style("width", (widthPTreePx + PTREE_N2_GAP_PX + WIDTH_N2_PX + 2*SVG_MARGIN) + "px")
                .style("height", (HEIGHT_PX + 2*SVG_MARGIN) + "px");
            svg.attr("width", widthPTreePx + PTREE_N2_GAP_PX + WIDTH_N2_PX + 2*SVG_MARGIN)
                .attr("height", HEIGHT_PX + 2*SVG_MARGIN);
            n2Group.attr("transform", "translate(" + (widthPTreePx + PTREE_N2_GAP_PX + SVG_MARGIN) + "," + SVG_MARGIN + ")");
            pTreeGroup.attr("transform", "translate(" + SVG_MARGIN + "," + SVG_MARGIN + ")");

            // Compute the new tree layout.
            ComputeLayout(); //updates d3NodesArray
            ComputeMatrixN2();

            //update svg dimensions with transition after ComputeLayout() changes widthPTreePx
            svgDiv.transition(sharedTransition).style("width", (widthPTreePx + PTREE_N2_GAP_PX + WIDTH_N2_PX + 2*SVG_MARGIN) + "px")
                .style("height", (HEIGHT_PX + 2*SVG_MARGIN) + "px");
            svg.transition(sharedTransition).attr("width", widthPTreePx + PTREE_N2_GAP_PX + WIDTH_N2_PX + 2*SVG_MARGIN)
                .attr("height", HEIGHT_PX + 2*SVG_MARGIN);
            n2Group.transition(sharedTransition).attr("transform", "translate(" + (widthPTreePx + PTREE_N2_GAP_PX + SVG_MARGIN) + "," + SVG_MARGIN + ")");
            pTreeGroup.transition(sharedTransition).attr("transform", "translate(" + SVG_MARGIN + "," + SVG_MARGIN + ")");


            for(var i=2; i<=maxDepth; ++i){
                var option = document.getElementById("myCollapseDepthSelectOption" + i);
                if(i <= zoomedElement.depth){
                    option.disabled = "disabled";
                }
                else{
                    option.removeAttribute("disabled");
                }
            }


            if(xScalerPTree0 != null){//not first run.. store previous
                kx0 = kx;
                ky0 = ky;
                xScalerPTree0 = xScalerPTree.copy();
                yScalerPTree0 = yScalerPTree.copy();
            }

            kx = (zoomedElement.x ? widthPTreePx - PARENT_NODE_WIDTH_PX : widthPTreePx) / (1 - zoomedElement.x);
            ky = HEIGHT_PX / zoomedElement.height;
            xScalerPTree.domain([zoomedElement.x, 1]).range([zoomedElement.x ? PARENT_NODE_WIDTH_PX : 0, widthPTreePx]);
            yScalerPTree.domain([zoomedElement.y, zoomedElement.y + zoomedElement.height]);

            if(xScalerPTree0 == null){ //first run.. duplicate
                kx0 = kx;
                ky0 = ky;
                xScalerPTree0 = xScalerPTree.copy();
                yScalerPTree0 = yScalerPTree.copy();
            }

            var sel = pTreeGroup.selectAll(".partition_group")
                .data(d3NodesArray, function(d) {
                    return d.id;
                });

            var nodeEnter = sel.enter().append("svg:g")
                .attr("class", function(d) {
                    return "partition_group " + getClass(d);
                })
                .attr("transform", function(d) {
                    return "translate(" + xScalerPTree0(d.x0) + "," + yScalerPTree0(d.y0) + ")";
                })
                .on("click", click)
                .on("contextmenu", rightClick);


            nodeEnter.append("svg:rect")
                .attr("width", function(d) {
                    return d.width0 * kx0;//0;//
                })
                .attr("height", function(d) {
                    return d.height0 * ky0;
                });

            nodeEnter.append("svg:text")
                .attr("dy", ".35em")
                //.attr("text-anchor", "end")
                .attr("transform", function(d) {
                    var anchorX = d.width0 * kx0 - RIGHT_TEXT_MARGIN_PX;
                    //var anchorX = -RIGHT_TEXT_MARGIN_PX;
                    return "translate(" + anchorX + "," + d.height0 * ky0 / 2 + ")";
                })
                .style("opacity", function(d) {
                    if(d.depth < zoomedElement.depth) return 0;
                    return d.height0 * ky0 > FONT_SIZE_PX ? 1 : 0;
                })
                .text(GetText);

            //d3.select(window).on("click", function() {
            //    click(root);
            //});

            var nodeUpdate = nodeEnter.merge(sel).transition(sharedTransition)
                .attr("class", function(d) {
                    return "partition_group " + getClass(d);
                })
                .attr("transform", function(d) {
                    return "translate(" + xScalerPTree(d.x) + "," + yScalerPTree(d.y) + ")";
                });

            nodeUpdate.select("rect")
                .attr("width", function(d) {
                    return d.width * kx;
                })
                .attr("height", function(d) {
                    return d.height * ky;
                });

            nodeUpdate.select("text")
                .attr("transform", function(d) {
                    var anchorX = d.width * kx - RIGHT_TEXT_MARGIN_PX;
                    return "translate(" + anchorX + "," + d.height * ky / 2 + ")";
                })
                .style("opacity", function(d) {
                    if(d.depth < zoomedElement.depth) return 0;
                    return d.height * ky > FONT_SIZE_PX ? 1 : 0;
                })
                .text(GetText);


            // Transition exiting nodes to the parent's new position.
            var nodeExit = sel.exit().transition(sharedTransition)
                .attr("transform", function(d) {
                    return "translate(" + xScalerPTree(d.x) + "," + yScalerPTree(d.y) + ")";
                })
                .remove();

            nodeExit.select("rect")
                .attr("width", function(d) {
                    return d.width * kx;//0;//
                })
                .attr("height", function(d) {
                    return d.height * ky;
                });

            nodeExit.select("text")
                .attr("transform", function(d) {
                    var anchorX = d.width * kx - RIGHT_TEXT_MARGIN_PX;
                    return "translate(" + anchorX + "," + d.height * ky / 2 + ")";
                    //return "translate(8," + d.height * ky / 2 + ")";
                });


            ClearArrows();
            DrawMatrix();
        }

        function ClearArrows(){
            n2Group.selectAll("[class^=n2_hover_elements]").remove();
        }


        function ExpandColonVars(d) {
            function findNameInIndex(arr, name) {
                for (var i = 0; i < arr.length; ++i) {
                    if (arr[i].name === name) return i;
                }
                return -1;
            }

            function addChildren(originalParent, parent, arrayOfNames, arrayOfNamesIndex, type) {
                if (arrayOfNames.length == arrayOfNamesIndex) return;

                var name = arrayOfNames[arrayOfNamesIndex];

                if (!parent.hasOwnProperty("children")) {
                    parent.children = [];
                }

                var parentI = findNameInIndex(parent.children, name);
                if (parentI == -1) { //new name not found in parent, create new
                    var newObj = {
                        "name": name,
                        "type": type,
                        "splitByColon": true,
                        "originalParent": originalParent
                    };
                    if(type === "param") {
                        parent.children.splice(0,0,newObj);
                    }
                    else {
                        parent.children.push(newObj);
                    }
                    addChildren(originalParent, newObj, arrayOfNames, arrayOfNamesIndex + 1, type);
                } else { //new name already found in parent, keep traversing
                    addChildren(originalParent, parent.children[parentI], arrayOfNames, arrayOfNamesIndex + 1, type);
                }
            }

            if (!d.children) return;
            for (var i = 0; i < d.children.length; ++i) {

                var splitArray = d.children[i].name.split(":");
                if (splitArray.length > 1) {
                    if(!d.hasOwnProperty("subsystem_type") || d.subsystem_type !== "component"){
                        alert("error: there is a colon named object whose parent is not a component");
                        return;
                    }
                    var type = d.children[i].type;
                    d.children.splice(i--, 1);
                    addChildren(d, d, splitArray, 0, type);
                }
            }
            for (var i = 0; i < d.children.length; ++i) {
                ExpandColonVars(d.children[i]);
            }
        }

        function FlattenColonGroups(d){
            if (!d.children) return;
            if(d.splitByColon && d.children.length == 1 && d.children[0].splitByColon){
                //alert("combine " + d.name + " " + d.children[0].name);
                var child = d.children[0];
                d.name += ":" + child.name;
                if(child.hasOwnProperty("children")) d.children = child.children;
            }
            if (!d.children) return;
            for (var i = 0; i < d.children.length; ++i) {
                FlattenColonGroups(d.children[i]);
            }
        }

        function GetText(d) {
            var retVal = d.name;
            if(outputNamingType === "Promoted" && (d.type === "unknown" || d.type === "param") && zoomedElement.promotions && zoomedElement.promotions[d.absPathName] !== undefined) {
                retVal = zoomedElement.promotions[d.absPathName];
            }
            if(d.splitByColon && d.children && d.children.length > 0) retVal += ":";
            return retVal;
        }

        //Sets parents, depth, and nameWidthPx of all nodes.  Also finds and sets maxDepth.
        function InitTree(d, parent, depth) {
            d.depth = depth;
            d.parent = parent;
            d.id = ++idCounter;
            d.absPathName = "";
            if(d.parent){ //not root node? d.parent.absPathName : "";
                if(d.parent.absPathName !== ""){
                    d.absPathName += d.parent.absPathName;
                    d.absPathName += (d.parent.splitByColon) ? ":" : ".";
                }
                d.absPathName += d.name;
            }
            maxDepth = Math.max(depth, maxDepth);
            if (d.children) {
                for (var i = 0; i < d.children.length; ++i) {
                    var implicit = InitTree(d.children[i], d, depth + 1);
                    if(implicit){
                        d.implicit = true;
                    }
                }
            }
            return (d.implicit) ? true : false;
        }


        function ComputeLayout() {
            var columnWidthsPx = new Array(maxDepth+1).fill(0.0),// since depth is one based
                columnLocationsPx = new Array(maxDepth+1).fill(0.0);

            var textWidthGroup = svg.append("svg:g").attr("class", "partition_group");
            var textWidthText = textWidthGroup.append("svg:text")
                .text("")
                .attr("x", -50); // Put text off screen
            var textWidthTextNode = textWidthText.node();

            function GetTextWidth(s){
                textWidthText.text(s);
                return textWidthTextNode.getBoundingClientRect().width;
            }

            function UpdateTextWidths(d) {
                if (!showParams && d.type === "param") return;
                d.nameWidthPx = GetTextWidth(GetText(d)) + 2 * RIGHT_TEXT_MARGIN_PX;
                if (d.children) {
                    for (var i = 0; i < d.children.length; ++i) {
                        UpdateTextWidths(d.children[i]);
                    }
                }
            }

            function ComputeColumnWidths(d) {
                var greatestDepth = 0;
                var leafWidthsPx = new Array(maxDepth+1).fill(0.0);

                function DoComputeColumnWidths(d) {
                    if(!showParams && d.type === "param") return;

                    //columnWidthsPx[d.depth] = Math.max(columnWidthsPx[d.depth], d.nameWidthPx);

                    greatestDepth = Math.max(greatestDepth, d.depth);

                    if(d.children && !d.isMinimized){ //not leaf
                        columnWidthsPx[d.depth] = Math.max(columnWidthsPx[d.depth], d.nameWidthPx);
                        for (var i = 0; i < d.children.length; ++i) {
                            DoComputeColumnWidths(d.children[i]);
                        }
                    }
                    else{ //leaf
                        leafWidthsPx[d.depth] = Math.max(leafWidthsPx[d.depth], d.nameWidthPx);
                    }
                }

                DoComputeColumnWidths(d);


                var sum = 0;
                var lastColumnWidth = 0;
                for(var i=leafWidthsPx.length-1; i>=zoomedElement.depth; --i){
                    sum += columnWidthsPx[i];
                    var lastWidthNeeded = leafWidthsPx[i] - sum;
                    lastColumnWidth = Math.max(lastWidthNeeded, lastColumnWidth);
                }
                columnWidthsPx[zoomedElement.depth-1] = PARENT_NODE_WIDTH_PX;
                columnWidthsPx[greatestDepth] = lastColumnWidth;

            }


            function ComputeLeaves(d) {
                if (!showParams && d.type === "param") {
                    d.numLeaves = 0;
                    return;
                }
                var doRecurse = d.children && !d.isMinimized;
                d.numLeaves = doRecurse ? 0 : 1; //no children: init to 0 because will be added later
                if (!doRecurse) return;

                for (var i = 0; i < d.children.length; ++i) {
                    ComputeLeaves(d.children[i]);
                    d.numLeaves += d.children[i].numLeaves;
                }
            }

            function ComputeNormalizedPositions(d, leafCounter, isChildOfZoomed, earliestMinimizedParent) {
                if (!showParams && d.type === "param") return;
                isChildOfZoomed = (isChildOfZoomed) ? true : (d === zoomedElement);
                if(earliestMinimizedParent == null && isChildOfZoomed){
                    d3NodesArray.push(d);
                    if (!d.children || d.isMinimized) { //at a "leaf" node
                        //if (isChildOfZoomed) {
                            d3RightTextNodesArrayZoomed.push(d);
                        //}
                        earliestMinimizedParent = d;
                    }
                }
                var node = (earliestMinimizedParent) ? earliestMinimizedParent : d;
                d.rootIndex = leafCounter;
                d.x0 = d.hasOwnProperty('x') ? d.x : 1e-6;
                d.y0 = d.hasOwnProperty('y') ? d.y : 1e-6;
                d.width0 = d.hasOwnProperty('width') ? d.width : 1e-6;
                d.height0 = d.hasOwnProperty('height') ? d.height : 1e-6;
                d.x = columnLocationsPx[node.depth] / widthPTreePx;
                d.y = leafCounter / root.numLeaves;
                d.width = (d.children && !d.isMinimized) ? (columnWidthsPx[node.depth] / widthPTreePx) : 1-node.x;//1-d.x;
                d.height = node.numLeaves / root.numLeaves;

                if(d.children){
                    for (var i = 0; i < d.children.length; ++i) {
                        ComputeNormalizedPositions(d.children[i], leafCounter, isChildOfZoomed, earliestMinimizedParent);
                        if(earliestMinimizedParent == null){ //numleaves is only valid passed nonminimized nodes
                            leafCounter += d.children[i].numLeaves;
                        }
                    }
                }
            }



            UpdateTextWidths(zoomedElement);
            ComputeLeaves(root);
            d3NodesArray = [];
            d3RightTextNodesArrayZoomed = [];

            //COLUMN WIDTH COMPUTATION
            ComputeColumnWidths(zoomedElement);
            // Now the column_width array is relative to the zoomedElement
            //    and the computation of the widths only includes visible items after the zoom
            widthPTreePx = 0;
            for(var depth = 1 ; depth <= maxDepth; ++depth) {
                columnLocationsPx[depth] = widthPTreePx;
                widthPTreePx += columnWidthsPx[depth];
            }

            ComputeNormalizedPositions(root, 0, false, null);
            if(zoomedElement.parent){
                d3NodesArray.push(zoomedElement.parent);
            }

            enterIndex = exitIndex = lastRightClickedElementIndex = 0;
            if(lastClickWasLeft){ //left click
                if(leftClickIsForward){
                    exitIndex = lastLeftClickedElement.rootIndex - zoomedElement0.rootIndex;
                }
                else{
                    enterIndex = zoomedElement0.rootIndex - lastLeftClickedElement.rootIndex;
                }
            }
            else{ //right click
                if(lastRightClickedElement != null){ //not a button collapse algorithm with many collapses at once
                    lastRightClickedElementIndex = lastRightClickedElement.rootIndex - zoomedElement.rootIndex;
                }
            }

            textWidthGroup.remove();

        }





        //right click => collapse
        function rightClick(d) {
            if (!d.children) return;
            if (d3.event.button != 2) return;
            if (d.depth > zoomedElement.depth) { //dont allow minimizing on root node
                lastRightClickedElement = d;
                lastClickWasLeft = false;
                toggle(d);
                update(d);
            }
            d3.event.preventDefault();
            d3.event.stopPropagation();
        }

        //left click => navigate
        function click(d) {
            if (!d.children) return;
            if (d3.event.button != 0) return;
            lastLeftClickedElement = d;
            lastClickWasLeft = true;
            if(lastLeftClickedElement.depth > zoomedElement.depth){
                leftClickIsForward = true; //forward
            }
            else if(lastLeftClickedElement.depth < zoomedElement.depth){
                leftClickIsForward = false; //backwards
            }
            zoomedElement0 = zoomedElement;
            zoomedElement = d;
            update();
            d3.event.preventDefault();
            d3.event.stopPropagation();
        }

        function getClass(d) {
            if (d.isMinimized) return "minimized";
            if (d.type === "param") {
                if(d.children && d.children.length > 0) return "param_group";
                return "param";
            }
            if (d.type === "unknown") {
                if(d.children && d.children.length > 0) return "unknown_group";
                return "unknown";
            }
            if (d.type === "root") return "subsystem";
            if(d.type === "subsystem") {
                if(d.subsystem_type === "component") return "component";
                return "subsystem";
            }
            alert("class not found");
        }



        function toggle(d) {

            if (d.isMinimized)
                d.isMinimized = false;
            else
                d.isMinimized = true;
        }

        function ComputeConnections() {
            function GetObjectInTree(d, nameArray, nameIndex) {
                if (nameArray.length == nameIndex) {
                    return d;
                }
                if (!d.children) {
                    return null;
                }

                for (var i = 0; i < d.children.length; ++i) {
                    if (d.children[i].name === nameArray[nameIndex]) {
                        return GetObjectInTree(d.children[i], nameArray, nameIndex + 1);
                    }
                    else {
                        var numNames = d.children[i].name.split(":").length;
                        if(numNames >= 2 && nameIndex + numNames <= nameArray.length){
                            var mergedName = nameArray[nameIndex];
                            for(var j=1; j<numNames; ++j){
                                mergedName += ":" + nameArray[nameIndex+j];
                            }
                            if (d.children[i].name === mergedName) {
                                return GetObjectInTree(d.children[i], nameArray, nameIndex + numNames);
                            }
                        }
                    }
                }
                return null;
            }

            var numElementsBefore = 0,
                numElementsAfter = 0;

            function RemoveDuplicates(d) { //remove redundant elements in every objects' sources and targets arrays
                if (d.children) {
                    for (var i = 0; i < d.children.length; ++i) {
                        RemoveDuplicates(d.children[i]);
                    }
                }

                function unique(elem, pos, arr) {
                    return arr.indexOf(elem) == pos;
                }

                /*if(d.sources){
                    numElementsBefore += d.sources.length;
                    var uniqueArray = d.sources.filter(unique);
                    d.sources = uniqueArray;
                    numElementsAfter += d.sources.length;
                }*/
                if (d.targets) {
                    numElementsBefore += d.targets.length;
                    var uniqueArray = d.targets.filter(unique);
                    d.targets = uniqueArray;
                    numElementsAfter += d.targets.length;
                }
            }

            function AddLeaves(d, objArray) {
                if (d.type !== "param") {
                    objArray.push(d);
                }
                if (d.children) {
                    for (var i = 0; i < d.children.length; ++i) {
                        AddLeaves(d.children[i], objArray);
                    }
                }
            }

            function ClearConnections(d) {
                d.targets = [];
                if (d.children) {
                    for (var i = 0; i < d.children.length; ++i) {
                        ClearConnections(d.children[i]);
                    }
                }
            }

            ClearConnections(root);

            for (var i = 0; i < conns.length; ++i) {
                var srcSplitArray = conns[i].src.split(/\.|:/);
                var srcObj = GetObjectInTree(root, srcSplitArray, 0);
                var srcObjArray = [];
                //if (srcObj.type === "param") { //source obj cannot be a param
                if (srcObj.type !== "unknown") { //source obj must be unknown
                    alert("error: there is a source that is a param.");
                    return;
                }
                AddLeaves(srcObj, srcObjArray); /////AddLeaves(srcObj.parent, srcObjArray);
                for (var obj = srcObj.parent; obj != null; obj = obj.parent) {
                    srcObjArray.push(obj);
                }

                var tgtSplitArray = conns[i].tgt.split(/\.|:/);
                var tgtObj = GetObjectInTree(root, tgtSplitArray, 0);
                var tgtObjArray = [tgtObj];
                if (tgtObj.type !== "param") { //target obj must be a param
                    alert("error: there is a target that is NOT a param.");
                    return;
                    //AddLeaves(tgtObj, tgtObjArray);
                }
                if(!showParams) AddLeaves(tgtObj.parent, tgtObjArray); //contaminate
                for (var obj = tgtObj.parent; obj != null; obj = obj.parent) {
                    tgtObjArray.push(obj);
                }


                for (var j = 0; j < srcObjArray.length; ++j) {
                    if (!srcObjArray[j].hasOwnProperty('targets')) srcObjArray[j].targets = [];
                    srcObjArray[j].targets = srcObjArray[j].targets.concat(tgtObjArray);
                    ////if(srcObjArray[j] === fc) alert(i+" "+j);
                }

                /*for(var j = 0; j < tgtObjArray.length; ++j){
                    if(!tgtObjArray[j].hasOwnProperty('sources')) tgtObjArray[j].sources = [];
                    tgtObjArray[j].sources = tgtObjArray[j].sources.concat(srcObjArray);
                }*/
                var cycleArrowsArray = [];
                if(conns[i].cycle_arrows && conns[i].cycle_arrows.length > 0){
                    var cycleArrows = conns[i].cycle_arrows;
                    for(var j=0; j<cycleArrows.length; ++j){
                        var cycleArrowsSplitArray = cycleArrows[j].split(" ");
                        if(cycleArrowsSplitArray.length != 2){
                            alert("error: cycleArrowsSplitArray length not 2: got " + cycleArrowsSplitArray.length);
                            return;
                        }
                        var splitArray = cycleArrowsSplitArray[0].split(/\.|:/);
                        var arrowBeginObj = GetObjectInTree(root, splitArray, 0);
                        splitArray = cycleArrowsSplitArray[1].split(/\.|:/);
                        var arrowEndObj = GetObjectInTree(root, splitArray, 0);
                        cycleArrowsArray.push({"begin":arrowBeginObj, "end": arrowEndObj});
                    }
                }
                if(cycleArrowsArray.length > 0){
                    if (!tgtObj.parent.hasOwnProperty("cycleArrows")) {
                        tgtObj.parent.cycleArrows = [];
                    }
                    tgtObj.parent.cycleArrows.push({"src":srcObj, "arrows": cycleArrowsArray});
                }

            }
            RemoveDuplicates(root);
            //alert(numElementsBefore + " " + numElementsAfter);
        }


        function ComputeMatrixN2() {
            matrix = {};
            if(d3RightTextNodesArrayZoomed.length < LEVEL_OF_DETAIL_THRESHOLD){
                for (var si = 0; si < d3RightTextNodesArrayZoomed.length; ++si) {
                    matrix[si + "_" + si] = {r: si, c: si, id: d3RightTextNodesArrayZoomed[si].id + "_" + d3RightTextNodesArrayZoomed[si].id};
                    var srcObj = d3RightTextNodesArrayZoomed[si];
                    for (var j = 0; j < srcObj.targets.length; ++j) {
                        var tgtObj = srcObj.targets[j];
                        var ti = d3RightTextNodesArrayZoomed.indexOf(tgtObj);
                        if (ti != -1) {
                            matrix[si + "_" + ti] = {r: si, c: ti, id: srcObj.id + "_" + tgtObj.id}; //matrix[si][ti].z = 1;
                        }
                    }
                    if(showParams && srcObj.type === "param"){
                        var srcParentComponent = (srcObj.originalParent) ? srcObj.originalParent : srcObj.parent;
                        for (var j = si+1; j < d3RightTextNodesArrayZoomed.length; ++j) {
                            var tgtObj = d3RightTextNodesArrayZoomed[j];
                            var tgtParentComponent = (tgtObj.originalParent) ? tgtObj.originalParent : tgtObj.parent;
                            if(srcParentComponent !== tgtParentComponent) break;
                            if(tgtObj.type === "unknown"){
                                var ti = j;
                                matrix[si + "_" + ti] = {r: si, c: ti, id: srcObj.id + "_" + tgtObj.id};
                            }
                        }
                    }
                }
            }
            n2Dx0 = n2Dx;
            n2Dy0 = n2Dy;

            n2Dx = WIDTH_N2_PX / d3RightTextNodesArrayZoomed.length;
            n2Dy = HEIGHT_PX / d3RightTextNodesArrayZoomed.length;
        }



        function DrawMatrix() {
            var symbols_scalar = [],
                symbols_vector = [],
                symbols_group = [],
                symbols_scalarScalar = [],
                symbols_scalarVector = [],
                symbols_vectorScalar = [],
                symbols_vectorVector = [],
                symbols_scalarGroup = [],
                symbols_groupScalar = [],
                symbols_vectorGroup = [],
                symbols_groupVector = [],
                symbols_groupGroup = [];



            for (var key in matrix) {
                var d = matrix[key];
                var tgtObj = d3RightTextNodesArrayZoomed[d.c], srcObj = d3RightTextNodesArrayZoomed[d.r];
                //alert(tgtObj.name + " " + srcObj.name);
                if (d.c == d.r) { //on diagonal
                    if (srcObj.type === "subsystem") { //group
                        symbols_group.push(d);
                    } else if (srcObj.type === "unknown" || (showParams && srcObj.type === "param")) {
                        if (srcObj.dtype === "ndarray") { //vector
                            symbols_vector.push(d);
                        } else { //scalar
                            symbols_scalar.push(d);
                        }
                    }

                }
                else if (srcObj.type === "subsystem"){
                    if(tgtObj.type === "subsystem") { //groupGroup
                        symbols_groupGroup.push(d);
                    }
                    else if(tgtObj.type === "unknown" || (showParams && tgtObj.type === "param")){
                        if (tgtObj.dtype === "ndarray"){//groupVector
                            symbols_groupVector.push(d);
                        }
                        else{//groupScalar
                            symbols_groupScalar.push(d);
                        }
                    }
                }
                else if (srcObj.type === "unknown" || (showParams && srcObj.type === "param")){
                    if (srcObj.dtype === "ndarray"){
                        if(tgtObj.type === "unknown" || (showParams && tgtObj.type === "param")) {
                            if (tgtObj.dtype === "ndarray" || (showParams && tgtObj.type === "param")){//vectorVector
                                symbols_vectorVector.push(d);
                            }
                            else{//vectorScalar
                                symbols_vectorScalar.push(d);
                            }

                        }
                        else if(tgtObj.type === "subsystem") { //vectorGroup
                            symbols_vectorGroup.push(d);
                        }
                    }
                    else { //if (srcObj.dtype !== "ndarray"){
                        if(tgtObj.type === "unknown" || (showParams && tgtObj.type === "param")) {
                            if (tgtObj.dtype === "ndarray"){//scalarVector
                                symbols_scalarVector.push(d);
                            }
                            else{//scalarScalar
                                symbols_scalarScalar.push(d);
                            }

                        }
                        else if(tgtObj.type === "subsystem") { //scalarGroup
                            symbols_scalarGroup.push(d);
                        }
                    }

                }
            }


            var u0 = n2Dx0 * .5,
                v0 = n2Dy0 * .5,
                u = n2Dx * .5,
                v = n2Dy * .5; //(0,0) = center of cell... (u,v) = bottom right of cell... (-u,-v) = top left of cell



            function cell_fill(d) {
                return (d3RightTextNodesArrayZoomed[d.c].implicit) ? n2OnDiagonalImplicitColor : n2OnDiagonalExplicitColor;
            }

            var currentBox = {"startI":0, "stopI":0};
            d3RightTextNodesArrayZoomedBoxInfo = [currentBox];
            for(var ri=1; ri<d3RightTextNodesArrayZoomed.length; ++ri){
                //boxes
                var el = d3RightTextNodesArrayZoomed[ri];
                var elParentComponent = (el.originalParent) ? el.originalParent : el.parent;
                var startINode = d3RightTextNodesArrayZoomed[currentBox.startI];
                var startParentComponent = (startINode.originalParent) ? startINode.originalParent : startINode.parent;
                if((el.type === "unknown" || (showParams && el.type === "param")) && elParentComponent
                    && ((elParentComponent.type === "subsystem" && elParentComponent.subsystem_type === "component")) //if is boxable
                    && startParentComponent === elParentComponent) {
                        ++currentBox.stopI;
                }
                else{
                    currentBox = {"startI":ri, "stopI":ri};
                }
                d3RightTextNodesArrayZoomedBoxInfo.push(currentBox);
            }
            //alert(JSON.stringify(d3RightTextNodesArrayZoomedBoxInfo));
            //return;

            var drawableBoxes = [];
            for(var i=0; i<d3RightTextNodesArrayZoomedBoxInfo.length; ++i){ //draw grid lines last so that they will always be visible
                var comp = d3RightTextNodesArrayZoomedBoxInfo[i];
                if(comp.startI == comp.stopI) continue;
                i=comp.stopI;
                comp.id = d3RightTextNodesArrayZoomed[comp.startI].id;
                drawableBoxes.push(comp);
            }



            var classes = ["cell_scalar", "cell_vector", "cell_group", "cell_scalarScalar", "cell_scalarVector", "cell_vectorScalar",
                "cell_vectorVector", "cell_scalarGroup", "cell_groupScalar", "cell_vectorGroup", "cell_groupVector", "cell_groupGroup"
            ];
            var datas = [symbols_scalar, symbols_vector, symbols_group, symbols_scalarScalar, symbols_scalarVector, symbols_vectorScalar,
                symbols_vectorVector, symbols_scalarGroup, symbols_groupScalar, symbols_vectorGroup, symbols_groupVector, symbols_groupGroup
            ];
            var drawFunctions = [DrawScalar, DrawVector, DrawGroup, DrawScalar, DrawVector, DrawVector,
                DrawVector, DrawGroup, DrawGroup, DrawGroup, DrawGroup, DrawGroup
            ];
            for(var i=0; i<classes.length; ++i){
                var sel = n2ElementsGroup.selectAll("." + classes[i])
                    .data(datas[i], function(d) {
                        return d.id;
                    });
                var gEnter = sel.enter().append("g")
                    .attr("class", classes[i])
                    .attr("transform", function(d) {
                        if(lastClickWasLeft) return "translate(" + (n2Dx0*(d.c-enterIndex)+u0) + "," + (n2Dy0*(d.r-enterIndex)+v0) + ")";
                        return "translate(" + (n2Dx0*lastRightClickedElementIndex+u0) + "," + (n2Dy0*lastRightClickedElementIndex+v0) + ")";
                    });
                drawFunctions[i](gEnter, u0, v0, (i<3) ? cell_fill : n2OffDiagonalColor, false)
                    .on("mouseover", (i<3) ? MouseoverOnDiagN2 : MouseoverOffDiagN2)
                    .on("mouseleave", MouseoutN2)
                    .on("click", MouseClickN2);


                var gUpdate = gEnter.merge(sel).transition(sharedTransition)
                    .attr("transform", function(d) {
                        return "translate(" + (n2Dx*(d.c)+u) + "," + (n2Dy*(d.r)+v) + ")";
                    });
                drawFunctions[i](gUpdate,u,v, (i<3) ? cell_fill : n2OffDiagonalColor, true);


                var nodeExit = sel.exit().transition(sharedTransition)
                    .attr("transform", function(d) {
                        if(lastClickWasLeft) return "translate(" + (n2Dx*(d.c-exitIndex)+u) + "," + (n2Dy*(d.r-exitIndex)+v) + ")";
                        return "translate(" + (n2Dx*lastRightClickedElementIndex+u) + "," + (n2Dy*lastRightClickedElementIndex+v) + ")";
                    })
                    .remove();
                drawFunctions[i](nodeExit,u,v, (i<3) ? cell_fill : n2OffDiagonalColor, true);
            }

            //do this so you save old index for the exit()
            var gridLines = [];
            if(d3RightTextNodesArrayZoomed.length < LEVEL_OF_DETAIL_THRESHOLD){
                for(var i=0; i<d3RightTextNodesArrayZoomed.length; ++i){
                    gridLines.push({"i":i, "id": d3RightTextNodesArrayZoomed[i].id});
                }
            }

            {
                var sel = n2GridLinesGroup.selectAll(".horiz_line")
                    .data(gridLines, function(d) {
                        return d.id;
                    });

                var gEnter = sel.enter().append("g")
                    .attr("class", "horiz_line")
                    .attr("transform", function(d) {
                        if(lastClickWasLeft) return "translate(0," + (n2Dy0*(d.i-enterIndex)) + ")";
                        return "translate(0," + (n2Dy0*lastRightClickedElementIndex) + ")";
                    });
                gEnter.append("line")
                    .attr("x2", WIDTH_N2_PX);

                var gUpdate = gEnter.merge(sel).transition(sharedTransition)
                    .attr("transform", function(d) {
                        return "translate(0," + (n2Dy*d.i) + ")";
                    });


                var nodeExit = sel.exit().transition(sharedTransition)
                    .attr("transform", function(d) {
                        if(lastClickWasLeft) return "translate(0," + (n2Dy*(d.i-exitIndex)) + ")";
                        return "translate(0," + (n2Dy*lastRightClickedElementIndex) + ")";
                    })
                    .remove();
            }

            {
                var sel = n2GridLinesGroup.selectAll(".vert_line")
                    .data(gridLines, function(d) {
                        return d.id;
                    });
                var gEnter = sel.enter().append("g")
                    .attr("class", "vert_line")
                    .attr("transform", function(d) {
                        if(lastClickWasLeft) return "translate(" + (n2Dx0*(d.i-enterIndex)) + ")rotate(-90)";
                        return "translate(" + (n2Dx0*lastRightClickedElementIndex) + ")rotate(-90)";
                    });
                gEnter.append("line")
                    .attr("x1", -HEIGHT_PX);

                var gUpdate = gEnter.merge(sel).transition(sharedTransition)
                    .attr("transform", function(d) {
                        return "translate(" + (n2Dx*d.i) + ")rotate(-90)";
                    });


                var nodeExit = sel.exit().transition(sharedTransition)
                    .attr("transform", function(d) {
                        if(lastClickWasLeft) return "translate(" + (n2Dx*(d.i-exitIndex)) + ")rotate(-90)";
                        return "translate(" + (n2Dx*lastRightClickedElementIndex) + ")rotate(-90)";
                    })
                    .remove();
            }


            {
                var sel = n2ComponentBoxesGroup.selectAll(".component_box")
                    .data(drawableBoxes, function(d) {
                        return d.id;
                    });
                var gEnter = sel.enter().append("g")
                    .attr("class", "component_box")
                    .attr("transform", function(d) {
                        if(lastClickWasLeft) return "translate(" + (n2Dx0*(d.startI-enterIndex)) + "," + (n2Dy0*(d.startI-enterIndex)) + ")";
                        return "translate(" + (n2Dx0*lastRightClickedElementIndex) + "," + (n2Dy0*lastRightClickedElementIndex) + ")";
                    });

                gEnter.append("rect")
                    .attr("width", function(d) {
                        if(lastClickWasLeft) return n2Dx0*(1+d.stopI-d.startI);
                        return n2Dx0;
                    })
                    .attr("height", function(d) {
                        if(lastClickWasLeft) return n2Dy0*(1+d.stopI-d.startI);
                        return n2Dy0;
                    });

                var gUpdate = gEnter.merge(sel).transition(sharedTransition)
                    .attr("transform", function(d) {
                        return "translate(" + (n2Dx*d.startI) + "," + (n2Dy*d.startI) + ")";
                    });

                gUpdate.select("rect")
                    .attr("width", function(d) {
                        return n2Dx*(1+d.stopI-d.startI);
                    })
                    .attr("height", function(d) {
                        return n2Dy*(1+d.stopI-d.startI);
                    });


                var nodeExit = sel.exit().transition(sharedTransition)
                    .attr("transform", function(d) {
                        if(lastClickWasLeft) return "translate(" + (n2Dx*(d.startI-exitIndex)) + "," + (n2Dy*(d.startI-exitIndex)) + ")";
                        return "translate(" + (n2Dx*lastRightClickedElementIndex) + "," + (n2Dy*lastRightClickedElementIndex) + ")";
                    })
                    .remove();

                nodeExit.select("rect")
                    .attr("width", function(d) {
                        if(lastClickWasLeft) return n2Dx*(1+d.stopI-d.startI);
                        return n2Dx;
                    })
                    .attr("height", function(d) {
                        if(lastClickWasLeft) return n2Dy*(1+d.stopI-d.startI);
                        return n2Dy;
                    });

            }
        }




        function dep_rect(x, y, width, height, fill) {
            n2Group.insert("rect")
                .attr("class", "n2_hover_elements")
                .attr("y", y)
                .attr("x", x)
                .attr("width", width)
                .attr("height", height)
                .attr("fill", fill)
                .attr("fill-opacity", "1");
        }


        function dep_path_2lines(x1, y1, x2, y2, x3, y3, color, width, useArrow) {
            var path = n2ArrowsGroup.insert("path")
                .attr("class", "n2_hover_elements")
                .attr("d", "M" + x1 + " " + y1 + " L" + x2 + " " + y2 + " L" + x3 + " " + y3)
                .attr("fill", "none")
                .style("stroke-width", width)
                .style("stroke", color);

            n2DotsGroup.append("circle")
                .attr("class", "n2_hover_elements")
                .attr("cx", x2)
                .attr("cy", y2)
                .attr("r", width * 1.0)
                .style("stroke-width", 0)
                .style("fill-opacity", 1)
                .style("fill", "black");
            n2DotsGroup.append("circle")
                .attr("class", "n2_hover_elements")
                .attr("cx", x2)
                .attr("cy", y2)
                .attr("r", width * 1.0)
                .style("stroke-width", 0)
                .style("fill-opacity", .75)
                .style("fill", color);

            if (useArrow) {
                path.attr("marker-end", "url(#arrow)");
            }
        }



        function MouseoverOffDiagN2(d){
            function DrawArrowsParamView(startIndex, endIndex) {
                //var leftTextWidthDependency = d3RightTextNodesArrayZoomed[i].nameWidthPx;

                var lineWidth = Math.min(5, n2Dx * .5, n2Dy * .5);
                arrowMarker.attr("markerWidth", lineWidth * .4)
                    .attr("markerHeight", lineWidth * .4);

                var boxStart = d3RightTextNodesArrayZoomedBoxInfo[startIndex];
                var boxEnd = d3RightTextNodesArrayZoomedBoxInfo[endIndex];

                //draw multiple horizontal lines but no more than one vertical line for box to box connections
                var startIndices = [], endIndices = [];
                for(var startsI=boxStart.startI; startsI<=boxStart.stopI; ++startsI){
                    for(var endsI=boxEnd.startI; endsI<=boxEnd.stopI; ++endsI){
                        if(matrix[startsI + "_" + endsI] !== undefined){ //if(matrix[startsI][endsI].z > 0){
                            startIndices.push(startsI);
                            endIndices.push(endsI);
                        }
                    }

                }

                for(var i=0; i<startIndices.length; ++i){
                    var startI = startIndices[i];
                    var endI = endIndices[i];

                    if(startIndex < endIndex){ //right down arrow
                        var x1 = (startI+1)*n2Dx; //x1
                        var x2 = (endI+.5)*n2Dx; //right x2
                        var x3 = x2; //down x3

                        var y1 = (startI+.5)*n2Dy; //y1
                        var y2 = y1; //right y2
                        var y3 = endI*n2Dy; //down y3

                        dep_path_2lines(x1, y1, x2, y2, x3, y3, n2ArrowGreenColor, lineWidth, true);

                    }
                    else if(startIndex > endIndex){ //left up arrow
                        //alert("yes");
                        var x1 = startI*n2Dx; //x1
                        var x2 = (endI+.5)*n2Dx; //left x2
                        var x3 = x2; //up x3

                        var y1 = (startI+.5)*n2Dy; //y1
                        var y2 = y1; //left y2
                        var y3 = (endI+1)*n2Dy; //y1

                        dep_path_2lines(x1, y1, x2, y2, x3, y3, n2ArrowRedColor, lineWidth, true);
                    }
                }
            }

            function DrawArrows(startIndex, endIndex) {
                //var leftTextWidthDependency = d3RightTextNodesArrayZoomed[i].nameWidthPx;

                var lineWidth = Math.min(5, n2Dx * .5, n2Dy * .5);
                arrowMarker.attr("markerWidth", lineWidth * .4)
                    .attr("markerHeight", lineWidth * .4);

                var boxStart = d3RightTextNodesArrayZoomedBoxInfo[startIndex];
                var boxEnd = d3RightTextNodesArrayZoomedBoxInfo[endIndex];

                //draw multiple horizontal lines but no more than one vertical line for box to box connections
                var startIndices = [];
                for(var startsI=boxStart.startI; startsI<=boxStart.stopI; ++startsI){
                    for(var endsI=boxEnd.startI; endsI<=boxEnd.stopI; ++endsI){
                        if(matrix[startsI + "_" + endsI] !== undefined){ //if(matrix[startsI][endsI].z > 0){
                            startIndices.push(startsI);
                            break;
                        }
                    }

                }

                for(var i=0; i<startIndices.length; ++i){
                    var startI = startIndices[i];
                    var boxEndDelta = boxEnd.stopI - boxEnd.startI;

                    if(startIndex < endIndex){ //right down arrow
                        var x1 = (startI+1)*n2Dx; //x1
                        var x2 = (endIndex+boxEndDelta*.5)*n2Dx + n2Dx*.5; //right x2
                        var x3 = x2; //down x3

                        var y1 = startI*n2Dy + n2Dy*.5; //y1
                        var y2 = y1; //right y2
                        var y3 = endIndex*n2Dy; //down y3

                        dep_path_2lines(x1, y1, x2, y2, x3, y3, n2ArrowGreenColor, lineWidth, true);

                    }
                    else if(startIndex > endIndex){ //left up arrow
                        //alert("yes");
                        var x1 = startI*n2Dx; //x1
                        var x2 = (endIndex+boxEndDelta*.5)*n2Dx + n2Dx*.5; //left x2
                        var x3 = x2; //up x3

                        var y1 = startI*n2Dy + n2Dy*.5; //y1
                        var y2 = y1; //left y2
                        var y3 = (endIndex+boxEndDelta+1)*n2Dy; //y1

                        dep_path_2lines(x1, y1, x2, y2, x3, y3, n2ArrowRedColor, lineWidth, true);
                    }
                }
            }

            function GetObjectsInChildrenWithCycleArrows(d, arr) {
                if (d.cycleArrows) {
                    arr.push(d);
                }
                if (d.children) {
                    for (var i = 0; i < d.children.length; ++i) {
                        GetObjectsInChildrenWithCycleArrows(d.children[i], arr);
                    }
                }
            }
            function GetObjectsWithCycleArrows(d, arr) {
                for (var obj = d.parent; obj != null; obj = obj.parent) { //start with parent.. the children will get the current object to avoid duplicates
                    if (obj.cycleArrows) {
                        arr.push(obj);
                    }
                }
                GetObjectsInChildrenWithCycleArrows(d, arr);
            }

            function HasObjectInChildren(d, toMatchObj) {
                if (d === toMatchObj) {
                    return true;
                }
                if (d.children) {
                    for (var i = 0; i < d.children.length; ++i) {
                        if (HasObjectInChildren(d.children[i], toMatchObj)) {
                            return true;
                        }
                    }
                }
                return false;
            }
            function HasObject(d, toMatchObj) {
                for (var obj = d; obj != null; obj = obj.parent) {
                    if(obj === toMatchObj){
                        return true;
                    }
                }
                return HasObjectInChildren(d, toMatchObj);
            }

            //alert("c=" + d.c + "  r=" + d.r);
            var lineWidth = Math.min(5, n2Dx * .5, n2Dy * .5);
            arrowMarker.attr("markerWidth", lineWidth * .4)
                .attr("markerHeight", lineWidth * .4);
            var src = d3RightTextNodesArrayZoomed[d.r];
            var tgt = d3RightTextNodesArrayZoomed[d.c];
            var boxEnd = d3RightTextNodesArrayZoomedBoxInfo[d.c];
            if(d.r > d.c){ //bottom left
                dep_path_2lines(
                    n2Dx*d.r, //x1
                    n2Dy*d.r + n2Dy * .5, //y1
                    n2Dx*d.c + n2Dx * .5, //left x2
                    n2Dy*d.r + n2Dy * .5, //left y2
                    n2Dx*d.c + n2Dx * .5, //up x3
                    (showParams) ? n2Dy*d.c + n2Dy - 1e-2 : n2Dy*(boxEnd.stopI) + n2Dy - 1e-2, //up y3
                    n2ArrowRedColor, lineWidth, true);

                //tgtObj.parent.cycleArrows.push({"src":srcObj, "arrows": cycleArrowsArray});
                var targetsWithCycleArrows = [];
                GetObjectsWithCycleArrows(tgt, targetsWithCycleArrows);
                for(var ti = 0; ti< targetsWithCycleArrows.length; ++ti){ //if(tgt.parent.cycleArrows){
                    var arrows = targetsWithCycleArrows[ti].cycleArrows;//tgt.parent.cycleArrows;
                    for(var ai=0; ai<arrows.length; ++ai){
                        if(HasObject(src, arrows[ai].src)){ //if(arrows[ai].src === src){
                            var correspondingSrcArrows = arrows[ai].arrows;
                            for(var si=0; si<correspondingSrcArrows.length; ++si){
                                var beginObj = correspondingSrcArrows[si].begin;
                                var endObj = correspondingSrcArrows[si].end;
                                //alert(beginObj.name + "->" + endObj.name);
                                var firstBeginIndex = -1, firstEndIndex = -1;

                                //find first begin index
                                for (var mi = 0; mi < d3RightTextNodesArrayZoomed.length; ++mi) {
                                    var rtNode = d3RightTextNodesArrayZoomed[mi];
                                    if(HasObject(rtNode, beginObj)){
                                        firstBeginIndex = mi;
                                        break;
                                    }
                                }
                                if(firstBeginIndex == -1){
                                    alert("error: first begin index not found");
                                    return;
                                }

                                //find first end index
                                for (var mi = 0; mi < d3RightTextNodesArrayZoomed.length; ++mi) {
                                    var rtNode = d3RightTextNodesArrayZoomed[mi];
                                    if(HasObject(rtNode, endObj)){
                                        firstEndIndex = mi;
                                        break;
                                    }
                                }
                                if(firstEndIndex == -1){
                                    alert("error: first end index not found");
                                    return;
                                }

                                if(firstBeginIndex != firstEndIndex){
                                    if(showParams){
                                        DrawArrowsParamView(firstBeginIndex, firstEndIndex);
                                    }
                                    else {
                                        DrawArrows(firstBeginIndex, firstEndIndex);
                                    }
                                }

                            }

                        }
                    }


                }

            }
            else if(d.r < d.c){ //top right
                dep_path_2lines(
                    n2Dx*d.r + n2Dx, //x1
                    n2Dy*d.r + n2Dy * .5, //y1
                    n2Dx*d.c + n2Dx * .5, //right x2
                    n2Dy*d.r + n2Dy * .5, //right y2
                    n2Dx*d.c + n2Dx * .5, //down x3
                    (showParams) ? n2Dy*d.c+1e-2 : n2Dy*boxEnd.startI+1e-2, //down y3
                    n2ArrowRedColor, lineWidth, true);
            }
            var leftTextWidthR = d3RightTextNodesArrayZoomed[d.r].nameWidthPx,
                leftTextWidthC = d3RightTextNodesArrayZoomed[d.c].nameWidthPx;
            dep_rect(-leftTextWidthR-PTREE_N2_GAP_PX, n2Dy*d.r, leftTextWidthR, n2Dy, n2ArrowRedColor); //highlight var name
            dep_rect(-leftTextWidthC-PTREE_N2_GAP_PX, n2Dy*d.c, leftTextWidthC, n2Dy, n2ArrowGreenColor); //highlight var name
        }


        function MouseoverOnDiagN2(d) {
            //d=hovered element
            var hoveredIndexRC = d.c; //d.x == d.y == row == col
            var leftTextWidthHovered = d3RightTextNodesArrayZoomed[hoveredIndexRC].nameWidthPx;

            // Loop over all elements in the matrix looking for other cells in the same column as
            var lineWidth = Math.min(5, n2Dx * .5, n2Dy * .5);
            arrowMarker.attr("markerWidth", lineWidth * .4)
                .attr("markerHeight", lineWidth * .4);
            dep_rect(-leftTextWidthHovered-PTREE_N2_GAP_PX, n2Dy*hoveredIndexRC, leftTextWidthHovered, n2Dy, n2HighlightHoveredColor); //highlight hovered
            for (var i = 0; i < d3RightTextNodesArrayZoomed.length; ++i) {
                var leftTextWidthDependency = d3RightTextNodesArrayZoomed[i].nameWidthPx;
                var box = d3RightTextNodesArrayZoomedBoxInfo[i];
                if(matrix[hoveredIndexRC + "_" + i] !== undefined){ //if (matrix[hoveredIndexRC][i].z > 0) { //i is column here
                    if (i < hoveredIndexRC) { //column less than hovered
                        if(showParams){
                            dep_path_2lines(
                                n2Dx*hoveredIndexRC, //x1
                                n2Dy*(hoveredIndexRC+.5), //y1
                                (i+.5)*n2Dx, //left x2
                                n2Dy*(hoveredIndexRC+.5), //left y2
                                (i+.5)*n2Dx, //up x3
                                (i+1)*n2Dy, //up y3
                                n2ArrowGreenColor, lineWidth, true);
                        }
                        else if(i==box.startI){
                            dep_path_2lines(
                                n2Dx*hoveredIndexRC, //x1
                                n2Dy*hoveredIndexRC + n2Dy * .5, //y1
                                (box.startI+(box.stopI - box.startI)*.5)*n2Dx + n2Dx*.5, //left x2
                                n2Dy*hoveredIndexRC + n2Dy * .5, //left y2
                                (box.startI+(box.stopI - box.startI)*.5)*n2Dx + n2Dx*.5, //up x3
                                n2Dy*box.stopI + n2Dy, //up y3
                                n2ArrowGreenColor, lineWidth, true);
                        }
                        dep_rect(-leftTextWidthDependency-PTREE_N2_GAP_PX, n2Dy*i, leftTextWidthDependency, n2Dy, n2ArrowGreenColor); //highlight var name

                    } else if (i > hoveredIndexRC) { //column greater than hovered
                        if(showParams){
                            dep_path_2lines(
                                n2Dx*hoveredIndexRC + n2Dx, //x1
                                n2Dy*(hoveredIndexRC + .5), //y1
                                (i+.5)*n2Dx, //right x2
                                n2Dy*(hoveredIndexRC + .5), //right y2
                                (i+.5)*n2Dx, //down x3
                                n2Dy*i, //down y3
                                n2ArrowGreenColor, lineWidth, true); //vertical down
                        }
                        else if(i==box.startI){
                            dep_path_2lines(
                                n2Dx*hoveredIndexRC + n2Dx, //x1
                                n2Dy*hoveredIndexRC + n2Dy * .5, //y1
                                (box.startI+(box.stopI - box.startI)*.5)*n2Dx + n2Dx*.5, //right x2
                                n2Dy*hoveredIndexRC + n2Dy * .5, //right y2
                                (box.startI+(box.stopI - box.startI)*.5)*n2Dx + n2Dx*.5, //down x3
                                n2Dy*box.startI, //down y3
                                n2ArrowGreenColor, lineWidth, true); //vertical down
                        }
                        dep_rect(-leftTextWidthDependency-PTREE_N2_GAP_PX, n2Dy*i, leftTextWidthDependency, n2Dy, n2ArrowGreenColor); //highlight var name
                    }
                }

                if(matrix[i + "_" + hoveredIndexRC] !== undefined){ //if (matrix[i][hoveredIndexRC].z > 0) { //i is row here
                    if (i < hoveredIndexRC) { //row less than hovered
                        dep_path_2lines(
                            n2Dx*i + n2Dx, //x1
                            n2Dy*i + n2Dy * .5, //y1
                            n2Dx*hoveredIndexRC + n2Dx * .5, //right x2
                            n2Dy*i + n2Dy * .5, //right y2
                            n2Dx*hoveredIndexRC + n2Dx * .5, //down x3
                            n2Dy*hoveredIndexRC, //down y3
                            n2ArrowRedColor, lineWidth, true); //vertical down
                        dep_rect(-leftTextWidthDependency-PTREE_N2_GAP_PX, n2Dy*i, leftTextWidthDependency, n2Dy, n2ArrowRedColor); //highlight var name
                    } else if (i > hoveredIndexRC) { //row greater than hovered
                        dep_path_2lines(
                            n2Dx*i, //x1
                            n2Dy*i + n2Dy * .5, //y1
                            n2Dx*hoveredIndexRC + n2Dx * .5, //left x2
                            n2Dy*i + n2Dy * .5, //left y2
                            n2Dx*hoveredIndexRC + n2Dx * .5, //up x3
                            n2Dy*hoveredIndexRC + n2Dy, //up y3
                            n2ArrowRedColor, lineWidth, true);
                        dep_rect(-leftTextWidthDependency-PTREE_N2_GAP_PX, n2Dy*i, leftTextWidthDependency, n2Dy, n2ArrowRedColor); //highlight var name
                    }
                }
            }
        }

        function MouseoutN2() {
            n2Group.selectAll(".n2_hover_elements").remove();
        }

        function MouseClickN2(d){
            var newClassName = "n2_hover_elements_" + d.r + "_" + d.c;
            var selection = n2Group.selectAll("." + newClassName);
            if(selection.size() > 0){
                selection.remove();
            }
            else{
                n2Group.selectAll("path.n2_hover_elements, circle.n2_hover_elements")
                    .attr("class", newClassName);
            }
        }



        function SetupLegend() {
            var numColumns = 2;
            var elementSize = 30, xOffset = 10, columnWidth = 300;
            var legendWidth = columnWidth*numColumns + 0, legendHeight = 360;
            var u = elementSize * .5;
            var v = u;

            d3.select("#d3_content_div").select("div.legend").remove();

            var svg_legend = d3.select("#d3_content_div").append("div")
                .attr("class", "legend")
                .style("width", legendWidth + "px")
                .style("height", legendHeight + "px")
                .append("svg:svg")
                .attr("width", legendWidth)
                .attr("height", legendHeight);


            svg_legend.append("rect")
                .attr("class", "background")
                .attr("width", legendWidth)
                .attr("height", legendHeight);
                //.style("fill", "#7f7");



            function CreateElementBorder(g){
                g.append("rect")
                    .attr("x", -u)
                    .attr("y", -v)
                    .attr("width", elementSize)
                    .attr("height", elementSize)
                    .style("stroke-width", 2)
                    .style("stroke", "white")
                    .style("fill", "none");
            }

            function CreateText(g, text){
                g.append("svg:text")
                    .attr("x", u+5)
                    .attr("y", 0)
                    .attr("dy", ".35em")//.attr("dominant-baseline", "middle")//
                    .attr("font-size", 20)
                    .text(text)
                    .style("fill", "black");
            }

            //title LEGEND
            {
                var el = svg_legend.append("g").attr("transform", "translate(" + (legendWidth*.5) + "," + (15) + ")");
                el.append("svg:text")
                    .attr("text-anchor", "middle")
                    .attr("dy", ".35em")//.attr("dominant-baseline", "middle")//
                    .attr("font-size", 30)
                    .attr("text-decoration", "underline")
                    .text("LEGEND")
                    .style("fill", "black");
            }

            //COLUMN TITLES
            {
                var text = ["Partition Tree Colors", "N^2 Symbols and Colors"];
                for(var i=0; i<text.length; ++i){
                    var el = svg_legend.append("g").attr("transform", "translate(" + (columnWidth*i+xOffset) + "," + (60) + ")");
                    el.append("svg:text")
                        .attr("dy", ".35em")//.attr("dominant-baseline", "middle")//
                        .attr("font-size", 24)
                        .attr("text-decoration", "underline")
                        .text(text[i])
                        .style("fill", "black");
                }
            }

            //PARTITION TREE COLORS
            {
                var text = ["Subsystem", "Component", "Unknown", "Unknown Group", "Collapsed"];
                var colors = [ptSubsystemColor, ptComponentColor, ptUnknownColor, ptUnknownGroupColor, ptCollapsedColor];
                if(showParams){
                    text.push("Param");
                    text.push("Param Group");
                    colors.push(ptParamColor);
                    colors.push(ptParamGroupColor);
                }
                for(var i=0; i<text.length; ++i){
                    var el = svg_legend.append("g").attr("transform", "translate(" + (columnWidth*0+xOffset+u) + "," + (80+40*i+v) + ")");
                    DrawLegendColor(el,u,v,colors[i],false);
                    CreateText(el, text[i]);
                }
            }

            //N2 SYMBOLS AND COLORS
            {
                var text = ["On Diagonal Explicit Color", "On Diagonal Implicit Color", "Off Diagonal Color", "Scalar", "Vector", "Group"];
                var colors = [n2OnDiagonalExplicitColor, n2OnDiagonalImplicitColor, n2OffDiagonalColor, n2OnDiagonalExplicitColor, n2OnDiagonalExplicitColor, n2OnDiagonalExplicitColor];
                var shapeFunctions = [DrawLegendColor, DrawLegendColor, DrawLegendColor, DrawScalar, DrawVector, DrawGroup];
                for(var i=0; i<text.length; ++i){
                    var el = svg_legend.append("g").attr("transform", "translate(" + (columnWidth*1+xOffset+u) + "," + (80+40*i+v) + ")");
                    shapeFunctions[i](el,u,v,colors[i],false);
                    if(i>=3) CreateElementBorder(el);
                    CreateText(el, text[i]);
                }
            }

        }

        function ReturnToRootButtonClick(){
            lastLeftClickedElement = root;
            zoomedElement0 = zoomedElement;
            zoomedElement = root;

            lastClickWasLeft = true;
            leftClickIsForward = false;

            update();
        }

        function CollapseOutputsButtonClick(startNode) {
            function CollapseOutputs(d){
                if (d.subsystem_type &&  d.subsystem_type === "component") {
                    d.isMinimized = true;
                }
                if(d.children){
                    for (var i = 0; i < d.children.length; ++i) {
                        CollapseOutputs(d.children[i]);
                    }
                }
            }
            lastClickWasLeft = false;
            lastRightClickedElement = null;

            CollapseOutputs(startNode);
            update();
        }

        function UncollapseButtonClick(startNode) {
            function Uncollapse(d){
                if(d.type !== "param") {
                    d.isMinimized = false;
                }
                if(d.children){
                    for (var i = 0; i < d.children.length; ++i) {
                        Uncollapse(d.children[i]);
                    }
                }
            }
            lastClickWasLeft = false;
            lastRightClickedElement = null;
            Uncollapse(startNode);
            update();
        }

        function CollapseToDepthSelectChange(){
            function CollapseToDepth(d,depth){
                if(d.type === "param" || d.type === "unknown") {
                    return;
                }
                if (d.depth < depth) {
                    d.isMinimized = false;
                }
                else {
                    d.isMinimized = true;
                }
                if(d.children){
                    for (var i = 0; i < d.children.length; ++i) {
                        CollapseToDepth(d.children[i],depth);
                    }
                }
            }

            var chosenDepth = parseInt(collapseDepthSelectElement.value);
            if(!isNaN(chosenDepth) && chosenDepth > zoomedElement.depth){
                CollapseToDepth(root,chosenDepth);
            }
            lastClickWasLeft = false;
            lastRightClickedElement = null;
            update();
            collapseDepthSelectElement.selectedIndex = 0;
        }

        function FontSizeSelectChange(){
            var fontSize = parseInt(fontSizeSelectElement.value);
            if(!isNaN(fontSize)){
                FONT_SIZE_PX = fontSize;
                UpdateSvgCss();
                update();
            }
            fontSizeSelectElement.selectedIndex = 0;
            fontSizeFirstOption.text = "Font Size (" + FONT_SIZE_PX + " px)";
        }

        function OutputNameSelectChange(){
            if(outputNamingType !== outputNamingSelectElement.value){
                outputNamingType = outputNamingSelectElement.value;
                update();
            }

            outputNamingSelectElement.selectedIndex = 0;
            outputNamingFirstOption.text = "Output Naming (" + outputNamingType + ")";
        }

        function ParamViewSelectChange(){
            if(paramViewType !== paramViewSelectElement.value){
                paramViewType = paramViewSelectElement.value;
                showParams = (paramViewType === "Visible");
                SetupLegend();
                ComputeConnections();
                update();
            }

            paramViewSelectElement.selectedIndex = 0;
            paramViewFirstOption.text = "Params (" + paramViewType + ")";
        }

        function ShowPathCheckboxChange(){
            currentPathElement.style.display = (document.getElementById("showCurrentPathCheckbox").checked) ? "block" : "none";
        }


        function SaveSvg(){
            //get svg element.
            var svgData = document.getElementById("svgId").outerHTML;

            //add name spaces.
            if(!svgData.match(/^<svg[^>]+xmlns="http\:\/\/www\.w3\.org\/2000\/svg"/)){
                svgData = svgData.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
            }
            if(!svgData.match(/^<svg[^>]+"http\:\/\/www\.w3\.org\/1999\/xlink"/)){
                svgData = svgData.replace(/^<svg/, '<svg xmlns:xlink="http://www.w3.org/1999/xlink"');
            }

            //add xml declaration
            svgData = '<?xml version="1.0" standalone="no"?>\r\n' + svgData;

            svgData = vkbeautify.xml(svgData);
            var svgBlob = new Blob([svgData], {type:"image/svg+xml;charset=utf-8"});
            var svgUrl = URL.createObjectURL(svgBlob);
            var downloadLink = document.createElement("a");
            downloadLink.href = svgUrl;
            downloadLink.download = "partition_tree_n2.svg";
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
        }
    </script>
% s